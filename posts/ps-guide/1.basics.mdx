---
title: "1. 시간복잡도, 공간복잡도 및 기본 지식"
description: "시간복잡도와 기본적인 사전 지식을 알아봅시다."
icon: ""
image: ""
tags:
  - ps, algorithm, boj, fastio
draft: false
date: 2024-07-30 14:45:13
series: 알고리즘 가이드
seriesIndex: 1
---

# 시간복잡도

시간복잡도는 어떤 알고리즘을 실행할 때 걸리는 시간을 나타내는 지표입니다.
정확히는 문제를 해결하는데 걸리는 시간과 입력 사이의 관계를 말합니다. 예를 들어 아래 코드를 보면

```cpp
for (int i = 0; i < n; i++)
  for (int j = 0; j < n; j++)
    // Do something
```

어떤 입력 $n$에 대해서 2중 for 루프를 돌고 있습니다. $n$이 10인 경우 100번, 100인 경우 10000번 반복하게 됩니다.
이런 경우 실행 속도는 입력에 대해 제곱의 관계를 갖게 되고 이것을 $O(n^2)$이라고 표현합니다.
대문자 O 안에 표현하기 때문에 빅-오(Big-O) 표기법 이라고도 합니다.
알고리즘 문제를 보면 시간 제한이 초 단위로 주어집니다. 답을 작성하기 전에 미리 시간복잡도를 예측할 수 있으면 생각한 답이
시간 제한에 걸리지 않는지 어느정도 예측할 수 있습니다. 1억($10^8$)을 1초라고 생각하고 시간복잡도를 통해 실행에 걸리는 시간을 예측할 수 있습니다.
예를 들어 $n$이 $1 \leq n \leq 10^6$인 경우 $O(n^2)$ 알고리즘은 최악의 경우 $10^{12}$번 연산을 하게 되어 $10^4$초가 걸리게 되므로
무조건 시간 초과를 받습니다. 따라서 다른 알고리즘을 사용하거나 최적화를 해야 합니다.

<br />
시간복잡도를 표기하는 방법에 주의해야 할 점이 있습니다. 예를 들어 아래 코드는

```cpp
for (int i = 0; i < 2; i++)
  for (int j = 0; j < n; j++)
    // Do something
```

직관적으로 봤을 때 $O(2n)$ 입니다. 하지만, 시간복잡도를 표기할 때 상수는 무시하고 제일 높은 차수만 남깁니다.
따라서 $O(n)$이 됩니다. 정확한 연산 횟수를 구하기 보단 입력이 증가할 때 실행 시간이 어떻게 변하는지 나타낸다고 생각하면 됩니다.
아래 코드는

```cpp
for (int i = 0; i < n; i++)
  for (int j = i; j < n; j++)
    // Do something
```

정확하게 표현하려고 하면 $O\left(\frac{n(n - 1)}{2}\right)$ 정도가 되겠지만 상수는 무시하고 가장 높은 차수만 남긴다고 했으므로
$O(n^2)$으로 표기합니다. 아래는 많이 사용하는 시간복잡도 표기입니다.

- $O(1)$: 입력에 관계없이 항상 상수 시간을 소요하는 꿈같은 알고리즘입니다. 대표적으로 배열에서 특정 인덱스에 접근하는 것이 상수 시간에 처리됩니다.
- $O(\log n)$: 컴퓨터에선 로그라고 하면 $\log_2$나 $\ln$이지만 모두 밑변환을 통해 상수 취급할 수 있으므로
  크게 상관 없습니다. 로그 시간을 사용하는 알고리즘은 이진 탐색이 대표적입니다.
- $O(n)$: 입력에 비례해서 선형적으로 증가하는 알고리즘입니다. 배열을 한 번 훑는 것이 선형 시간에 처리됩니다.
- $O(n \log n)$: 많은 알고리즘이 이 시간복잡도를 가집니다. $n$이 100만 처럼 큰 경우에도 시간 초과를 받지 않을 수 있습니다.
  대표적으로 퀵 정렬, 세그먼트 트리 등이 있습니다.
- $O(n^2)$: $n$이 커지면 시간초과를 받을 수 있습니다. 많은 문제에서 $n$이 10만으로 주어지는데 이런 경우 시간 초과를 받습니다.
- $O(n^3)$: $n$이 조금만 커져도 시간 초과를 받을 수 있기 때문에 $n$이 굉장히 작게 주어지는 경우에만 쓸 수 있는 알고리즙니다.
  대표적으로 플로이드-워셜 알고리즘 등이 있습니다.
- $O(a^n)$ : $a$값과 $n$이 조금만 커져도 시간복잡도가 기하급수적으로 증가합니다. 마찬가지로 $n$이 매우 작게 주어지는 경우에만 쓸 수 있습니다.

시간복잡도를 계산할 때는 최악의 경우를 기준으로 삼아야 합니다.
시간복잡도가 매우 큰 알고리즘을 사용하도록 의도하는 문제는 $n$을 굉장히 작은 범위에서 줍니다. 따라서 숫자의 범위를 잘 확인하고
사용할 알고리즘을 미리 선택해 가망이 없는 선택지는 포기해야 합니다. 자신이 사용할 알고리즘의 시간복잡도를 미리 알고 있는 것도 중요합니다.
또, 빠른 알고리즘을 사용하더라도 불필요한 반복이 많거나 적절한 최적화를 하지 않았다면 시간 초과를 받을 수 있으니 주의해야 합니다.

# 공간복잡도

공간복잡도는 시간복잡도와 굉장히 유사한 개념인데 일반적으로 메모리 제한을 빡빡하게 주는 문제는 많지 않아서 크게 신경쓰지 않아도 되는 경우가 많습니다.

```cpp
int a[n][n];
```

이 배열은 $n \times n$ 크기의 배열이므로 $O(n^2)$의 공간복잡도를 가집니다. $n$이 100만인 경우 $4 \times 10^{12}$ 바이트
($\approx 3.6$ TB)의 메모리를사용하므로 코드가 정상적으로 실행되지 않을 것입니다. 공간복잡도는 시간복잡도와 마찬가지로 대문자 O를 사용해 표기합니다.
공간복잡도를 줄이는 것은 굉장히 어려워서 일반적으로 메모리 제한을 낮게 주지 않지만 메모리 제한이 빡빡하게 주어진 문제를 만났을 경우
공간복잡도를 고려해서 코드를 짜야 합니다.

# 입출력

알고리즘 문제는 대부분 입력을 받고 적절한 출력을 하는 형식입니다. 입출력은 모든 문제의 기본이 되므로 확실하게 알아두고 가야 합니다.
특히 입출력이 늦어 시간 초과를 받으면 굉장히 억울하니 적절한 처리를 해야 합니다.

<br />
대부분의 온라인 저지는 표준 입출력(stdio)를 사용합니다. 표준 입력(stdin) 채널과 표준
출력(stdout) 채널이 분리되어 있으므로 출력을 마지막에 모아서 하지 않고 그때그때 해도(입력을
다 받지 않고 해도) 출력만 따로 모아져서 채점되니 괜찮습니다. 불필요한 출력을 하면
그것도 채점에 포함되서 오답 처리될 수 있으니 필요한 출력만 해야 합니다.
<br />
C++은 `cin`으로 입력을 받는데 cin은 공백이나 개행문자를 만날때까지 입력을 받습니다.
그래서 입력이 한 줄에 띄어쓰기로 구분되던 개행문자로 구분되던 크게 상관이 없습니다.
하지만 Python은 `input()` 함수를 사용하는데 줄 단위로 읽기 때문에 입력의 형식이 중요합니다.
예를 들어 아래와 같은 입력이 주어진다고 생각해봅시다.

#### 입력

첫번째 줄에 정수 $n$이 주어진다. ($1 \leq n \leq 10,000$)

두번째 줄에 $n$개의 정수 $a_i$가 주어진다. ($-10^9 \leq a_i \leq 10^9$)

#### 예시 입력

```text
5
1 2 3 4 5
```

```text
10
-1 2 -3 4 -5 6 -7 8 -9 10
```

C++의 경우

```cpp
#include <iostream>

using namespace std;

int main() {
  int n;
  cin >> n;
  int a[n];
  for (int i = 0; i < n; i++)
    cin >> a[i];

  return 0;
}
```

Python의 경우

```python
n = int(input())
a = list(map(int, input().split()))
```

와 같이 처리할 수 있습니다. 입출력을 연습하기 위해 [1000번: A + B](https://www.acmicpc.net/problem/1000)를 풀어보시는 것을 추천합니다.

## 빠른 입출력

입출력에 소모되는 시간이 생각보다 많습니다. 코드를 정확하게 만들었어도 입출력 때문에 시간 초과를 받는 굉장히 억울한 경우가 생길 수 있습니다.
그래서 코드 몇 줄을 추가해서 입출력 속도를 늘려야 합니다. fastio라고 부릅니다.

### C++

C++에선 C스타일의 printf, scanf 와 C++ 스타일의 cin, cout이 있습니다. 두 방법을 섞어 사용해
도 문제가 되지 않도록 서로 버퍼를 동기화 하는 과정이 있습니다. 이 부분에서 많은 시간이 소요되므로 비활성화 하는 코드를 추가해야 합니다.

```cpp
#include <iostream>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
}
```

대신 이 방법을 사용하면 을 스타일 입출력과 C++ 스타일 입출력을 섞어 사용하면 안됩니다.

### Python

파이썬은 sys 모듈을 통해 좀더 낮은 레벨의 빠른 입출력을 사용할 수 있습니다.

```python
import sys

n = int(sys.stdin.readline())
```

처럼 사용할 수 있습니다. 참고로, readline 은 개행문자까지 읽기 때문에 맨 뒤에 개행문자가 함께 입력됩니다.
민감한 경우 rstrip을 통해 제거해 주어야 합니다. 편의를 위해 아래와 같은 방식으로도 많이 사용합니다.

```python
import sys
input = sys.stdin.readline

n = int(input())
```

혹시나 극한의 빠른 입출력을 원한다면 낮은 레벨의 입출력을 직접 구현해서 사용할 수 있습니다. 자세한 구현은
[jinhan814님의 글](https://www.acmicpc.net/blog/view/105)에서 찾아볼 수 있습니다.
이 방법은 시간 초과를 피하기 위해서라기 보다 입력으로 소요되는 시간을 줄여 순위를 높이기 위한 방법입니다.
백준에서 "푼 사람"탭을 보면 실행 시간을 기준으로 정렬되는데 입력이 많은 문제에서 상위권을 하고 싶다면 사용해보세요.

# 연습문제

- [100번: A + B](https://www.acmicpc.net/problem/1000)
- [10950번: A + B - 3](https://www.acmicpc.net/problem/10950)
- [15552번: 빠른 A + B](https://www.acmicpc.net/problem/15552)
